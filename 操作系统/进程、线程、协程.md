# 进程、线程、协程

## 进程



### 描述

进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中分配和管理资源的基本单位

### 与Cpu关系

操作系统会拆分CPU为一段段时间的运行片，轮流分配给不同的程序

对于多cpu，多个进程可以并行在多个cpu中计算，当然也会存在进程切换

对于单cpu，多个进程在这个单cpu中是并发运行，根据时间片读取上下文+执行程序+保存上下文

同一个进程同一时间段只能在一个cpu中运行，如果进程数小于cpu数，那么未使用的cpu将会空闲

### 多进程

指计算机系统可以同时执行多个进程，从一个进程到另外一个进程的转换是由操作系统内核管理的，一般是同时运

行多个软件



### 与线程区别

- 进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

- 一个程序有至少一个进程，一个进程有至少一个线程
- 进程有自己的独立地址空间，线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多
- 多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间
- 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行

### 进程间通信

-  管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在父子进程关系（亲缘关系）进程间使用。
- 命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
- 消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
- 共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。
- 信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
- 套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。
- 信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

## 线程

### 描述

- 操作系统能够进行运算调度的最小单位。线程被包含在进程之中，是进程中的实际运作单位，一个进程内可以包含多个线程，

-  线程是资源调度的最小单位
- 线程在等待IO的过程中会陷入阻塞状态



### 资源和开销

- 同一进程中的多条线程共享该进程中的全部系统资源，如虚拟地址空间，文件描述符文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈、寄存器环境、线程本地存储等信息。

- 线程创建的开销主要是线程堆栈的建立，分配内存的开销。这些开销并不大，**最大**的开销发生在**线程上下文切换**的时候。

### 线程间通信

注：**线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制**

- 锁机制：包括互斥锁、条件变量、读写锁、**自旋锁**
- 互斥锁**提供了以排他方式防止数据结构被并发修改的方法。互斥锁确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。

- **读写锁**允许多个线程同时读共享数据，而对写操作是互斥的。当以写模式加锁而处于写状态时任何试图加锁的线程(不论是读或写)都阻塞，当以读状态模式加锁而处于读状态时“读”线程不阻塞，“写”线程阻塞。读模式共享，写模式互斥。

- **条件变量**可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。

- **自旋锁**上锁受阻时线程不阻塞而是在循环中轮询查看能否获得该锁，没有线程的切换因而没有切换开销，不过对CPU的霸占会导致CPU资源的浪费。 所以自旋锁适用于并行结构(多个处理器)或者适用于锁被持有时间短而不希望在线程切换产生开销的情况。

-  **信号量机制(Semaphore)**：包括无名线程信号量和命名线程信号量 **信号机制(Signal)**：类似进程间的信号处理

- **线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。**





## 协程

### 描述

- 协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。

- 协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。
- 协程只有在等待IO的过程中才能重复利用线程
- 在协程中不能调用导致线程阻塞的操作。也就是说，协程只有和异步IO结合起来，才能发挥最大的威力。

### 资源开销

- 协程的调度完全由用户控制
  - 协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作用户空间栈，完全没有内核切换的开销
- Goroutine 是 Golang 的协程实现。Goroutine 的栈只有 2KB大小，而且是**动态伸缩**的，可以按需调整大小，最大可达 1G 相比线程来说既不浪费又灵活
- 线程也都有一个固定大小的内存块来做栈，一般会是 2MB 大小，线程栈会用来存储线程上下文信息。2MB 的线程栈和协程栈相比大了很多

### 阻塞

- 协程中调用阻塞式i/o会阻塞整个线程，因为协程之间的调度是**用户在协程中主动调用协程切换功能**（比如yield语句）手动实现的，而不是系统自动强制执行的，如果一个协程调用了阻塞式i/o，这个协程就被阻塞了，就无法调用协程切换功能去执行其它协程，也就意味着整个线程被阻塞了，所以协程中是不能直接调用任何会阻塞线程的功能的，需要进行封装。

- 对阻塞式操作的封装不是简单的让出协程执行权，因为一旦让出执行权，该协程就不会被继续执行，后续的阻塞式操作也就没有机会被完成了，正确的做法是新建一个线程或者从线程池中分配一个线程，在这个线程中执行需要的阻塞式操作，同时将当前协程休眠（让出执行权），在新线程中的操作完成后，再唤醒协程。

