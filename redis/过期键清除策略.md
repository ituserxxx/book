# redis过期策略、淘汰机制

### 定时删除

指的是设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作；

### 定期删除

redis默认每隔100ms就随机抽取一些设置了过期时间的key， 检测这些key是否过期，如果过期了就将其删掉。
**为什么会选择一部分，而不是全部**：因为如果这是redis里面有大量的key都设置了过期时间，那么如果全部去检测一遍，CPU负载就会很高，
会浪费大量的时间在检测上面，甚至直接导致redis挂掉。所有只会抽取一部分而不会全部检查。**出现问题**：这样的话就会出现大量的
已经过期的key并没有被删除，这就是 **为什么有时候大量的key明明已经过了失效时间，但是redis的内存还是被大量占用的原因** ，为了解决这个问题，
就需要 **惰性删除** 这个策略了。

### 惰性删除

惰性删除不在是redis去主动删除，而是在你要获取某个key 的时候，redis会先去检测一下这个key是否已经过期，如果没有过期则返回给你，
如果已经过期了，那么redis会删除这个key，不会返回给你。

这样两种策略就保证了 **过期的key最终一定会被删除掉** ，但是这只是保证了最终一定会被删除，要是定时删除漏掉了大量过期的key，
而且我们也没有及时的去访问这些key，那么这些key不就不会被删除了吗？不就会一直占着我们的内存吗?这样不还是会导致redis内存耗尽吗？

由于存在这样的问题，所以redis引入了 **内存淘汰机制** 来解决。

### 内存淘汰机制

通过设置参数：maxmemory-policy
内存淘汰机制就保证了在redis的内存占用过多的时候，去进行内存淘汰，也就是删除一部分key，保证redis的内存占用率不会过高，那么它会删除那些key呢？

- noeviction（不开启）：当内存不足以容纳新写入数据时，新写入操作会报错，无法写入新数据，一般不采用
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key，这个是最常用的
- allkeys-random：当内存不足以容纳新写入的数据时，在键空间中，随机移除key，一般也不使用
- allkeys-ttl： 移除即将过期的key(minor TTL)
- volatile-lru：volatile-lru：当内存不足以容纳新写入数据时，在**设置了过期时间**的键空间中，移除最近最少使用的key（这个一般不太合适） 
- volatile-random：当内存不足以容纳新写入数据时，在**设置了过期时间**的键空间中，随机移除某个key 
- volatile-ttl：当内存不足以容纳新写入数据时，在**设置了过期时间**的键空间中，有更早过期时间的key优先移除

### Redis过期键采用的是定期删除+惰性删除二者结合的方式进行删除的。
